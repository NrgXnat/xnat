/*
 * DicomDB: org.nrg.dcm.DirectoryRecord
 * XNAT http://www.xnat.org
 * Copyright (c) 2017, Washington University School of Medicine
 * All Rights Reserved
 *
 * Released under the Simplified BSD.
 */
package org.nrg.dcm;

import java.lang.ClassCastException;
import java.lang.Comparable;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.LinkedList;
import java.util.ListResourceBundle;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.HashSet;
import java.util.TreeSet;

import org.dcm4che2.data.Tag;

/**
 * Corresponds roughly to DICOMDIR Directory Record.
 * Each object is part of a tree optionally generated by a FileSet.
 * 
 * @author Kevin A. Archie &lt;karchie@wustl.edu&gt;
 * @version $Revision: 1.7 $
 */
public class DirectoryRecord implements Comparable<DirectoryRecord> {
  /**
   * DICOM Directory Record types
   */
  static final public class Type {
    // Better to read from properties file.
    private static final ResourceBundle rsrcb = new ListResourceBundle() {
      @Override
      public Object[][] getContents() {
	return contents;
      }
      final Object[][] contents = {
	  // LOCALIZE THIS
	  {"PATIENT", "Patient"},     // DICOM File-set record entry types
	  {"STUDY", "Study"},
	  {"SERIES", "Series"},
	  {"IMAGE", "Image"}
      };
    };

    private static final Map<String,Type> types = new HashMap<String,Type>();
    private final Collection<Integer> baseSelectionTags = new TreeSet<Integer>();
    private final String type;        // DICOM Folder Entity type
    private final String display;     // localized version of entity type

    private Type(final String type, final Integer...selectionTags) {
      this.type = type;
      types.put(type, this);
      this.display = rsrcb.getString(type);
      if (null != selectionTags) {
	this.baseSelectionTags.addAll(Arrays.asList(selectionTags));
      }
    }

    /**
     * Returns the instance representing the named directory record
     * type, or null if the named type is not defined
     * @param type DICOM string representation of the desired type
     * @return The corresponding Type instance, or null if none exists
     */
    public static Type getInstance(final String type) {
      return types.get(type);
    }

    @Override
    public boolean equals(final Object o) { return o instanceof Type && type.equals(((Type)o).type); }

    @Override
    public int hashCode() { return type.hashCode(); }

    @Override
    public String toString() { return display; }

    /**
     * @param s A string to be compared against the indicated type
     * @return true if the string equals the corresponding specifier in a DICOMDIR
     *  (PATIENT, STUDY, SERIES, or IMAGE; also Folder for filesystem directories)
     */
    public boolean matches(String s) { return type.equals(s); }

    public static final Type PATIENT = new Type("PATIENT", Tag.PatientID);
    public static final Type STUDY = new Type("STUDY", Tag.StudyDate, Tag.StudyTime, Tag.StudyID);
    public static final Type SERIES = new Type("SERIES", Tag.Modality, Tag.SeriesInstanceUID, Tag.SeriesNumber);
    public static final Type INSTANCE = new Type("IMAGE", Tag.InstanceNumber, Tag.ReferencedFileID);

    public static final Type[] getTypes() {
      return new Type[] {PATIENT, STUDY, SERIES, INSTANCE};
    }
  }

  static public abstract class Template {
    private final Type type;
    private final Collection<Integer> selectionKeys;

    // Order of selection keys specifies comparison order: earlier keys are more significant
    public Template(final Type type, final Collection<Integer> selectionKeys) {
      this.type = type;
      this.selectionKeys = new LinkedHashSet<Integer>(selectionKeys);
    }

    public Template(final Type type, final Integer...selectionKeys) {
      this(type, Arrays.asList(selectionKeys));
    }

    public final Type getType() { return type; }

    protected final String concatWithSpaces(final String...elems) {
      final StringBuilder sb = new StringBuilder();
      if (elems.length > 0)
	sb.append(elems[0]);
      for (int i = 1; i < elems.length; i++) {
	sb.append(" ");
	sb.append(elems[i]);
      }
      return sb.toString();
    }

    protected final void addKeys(Collection<Integer> keys) {
      selectionKeys.addAll(keys);
    }

    public abstract String display(DirectoryRecord r);

    public final static class Extended extends Template {
      private final Template baseTemplate;

      public Extended(final Template template, final Collection<Integer> addSelectionKeys) {
	super(template.type, template.selectionKeys);
	baseTemplate = template;
	addKeys(addSelectionKeys);
      }

      public Extended(final Template template, final Integer...addSelectionKeys) {
	this(template, Arrays.asList(addSelectionKeys));
      }

      @Override
      public String display(final DirectoryRecord r) { return baseTemplate.display(r); }
    };

    public static final Template PATIENT = new Template(Type.PATIENT, Tag.PatientID) {
      @Override
      public String display(final DirectoryRecord r) {
	return concatWithSpaces(this.getType().toString(), r.getValue(Tag.PatientID));
      }
    };

    public static final Template STUDY = new Template(Type.STUDY, Tag.StudyID, Tag.StudyDate, Tag.StudyTime) {
      @Override
      public String display(final DirectoryRecord r) {
	return concatWithSpaces(this.getType().toString(), r.getValue(Tag.StudyID));
      }
    };

    public static final Template SERIES = new Template(Type.SERIES, Tag.Modality, Tag.SeriesNumber, Tag.SeriesInstanceUID) {
      @Override
      public String display(final DirectoryRecord r) {
	return concatWithSpaces(r.getValue(Tag.Modality), this.getType().toString(), r.getValue(Tag.SeriesNumber));
      }
    };

    public static final Template INSTANCE = new Template(Type.INSTANCE, Tag.InstanceNumber, Tag.ReferencedFileID) {
      @Override
      public String display(final DirectoryRecord r) {
	return concatWithSpaces(this.getType().toString(), r.getValue(Tag.InstanceNumber), ":", r.getValue(Tag.ReferencedFileID));
      }
    };

  }

  private final Template template;

  public interface Factory {
    DirectoryRecord newInstance(Type type, DirectoryRecord upper, Map<Integer,String> values);
    Collection<Integer> getSelectionKeys(Type type);
  }

  private DirectoryRecord upper = null;
  private final Collection<DirectoryRecord> lower = new TreeSet<DirectoryRecord>();
  private final Map<Integer,String> values;

  protected DirectoryRecord(final Template template, final DirectoryRecord upper, final Map<Integer,String> values) {
    this.template = template;
    this.values = new HashMap<Integer,String>(values);
    setUpper(upper);
  }

  public final void setUpper(final DirectoryRecord upper) {
    if (this.upper == null) {
      this.upper = upper;
      if (upper != null) upper.addLower(this);
    } else if (this.upper != upper)
      throw new IllegalArgumentException("redefined directory record parent");
  }

  public final DirectoryRecord getUpper() { return upper; }

  private final void addLower(final DirectoryRecord... r) {
    if (r != null && r.length > 0) {
      lower.addAll(Arrays.asList(r));
    }
  }

  public final List<DirectoryRecord> getLower() {
    return new LinkedList<DirectoryRecord>(lower);
  }

  /**
   * Retrieve the DICOM tags for attributes required to be defined for
   * this Directory Record.  Exactly which attributes are required
   * depends on the record type.
   * @return DICOM tags for required attributes
   */
  public Integer[] getSelectionKeys() { return template.selectionKeys.toArray(new Integer[0]); }

  /**
   * @return the Type object specifying what type of directory record this is
   */
  public final Type getType() { return template.type; }

  public final String getValue(final int tag) { return values.get(tag); }

  public int compareTo(final DirectoryRecord other) {
    if (template.type != other.template.type) throw new ClassCastException();
    return compareAttributes(other);
  }

  @Override
  public boolean equals(final Object o) {
    if (!(o instanceof DirectoryRecord))
      return false;
    final DirectoryRecord odr = (DirectoryRecord) o;
    return this.template.type == odr.template.type && this.values.equals(odr.values);
  }

  @Override
  public int hashCode() {
    int result = 17;
    result = 37*result + template.type.hashCode();
    result = 37*result + values.hashCode();
    return result;
  }

  @Override
  public String toString() {
    return template.display(this);
  }

  /**
   * Remove any Directory Records matching the constraints, starting from this
   * record and descending through its tree of children.
   * @param rs records to be removed
   * @return Collection of all referenced file IDs removed.
   */
  public Collection<String> purge(final Collection<DirectoryRecord> rs) {
    final Set<String> purgedFiles = new HashSet<String>();

    // we iterate over the lower list, but in that loop some lower elements might
    // remove themselves, which would mess up the iteration.
    final Set<DirectoryRecord> tl = new HashSet<DirectoryRecord>(lower);

    if (rs == null || rs.contains(this)) {	// require instance identity, not just equivalence
      upper.lower.remove(this);
      if (values.containsKey(Tag.ReferencedFileID)) {
	assert lower.size() == 0;	// this is an instance
	purgedFiles.add(values.get(Tag.ReferencedFileID));
      } else {
	// Remove all files below this one.  
	for (final DirectoryRecord r : tl)
	  purgedFiles.addAll(r.purge());
      }
    } else {
      // This record isn't removed, but lower ones might be.
      for (final DirectoryRecord r : tl)
	purgedFiles.addAll(r.purge(rs));
    }

    // Remove this (non-image) record if it's empty.
    if (!template.type.equals(Type.INSTANCE) && upper != null && lower.size() == 0)
      upper.lower.remove(this);

    return purgedFiles;
  }

  public Collection<String> purge(final DirectoryRecord...rs) {
    return purge(Arrays.asList(rs));
  }

  public Collection<String> purge() {
    return purge((Collection<DirectoryRecord>)null);
  }


  /**
   * Compares attributes that might end in integer values. If they do end
   * in integers, ordering is alphabetical by the first part, then numeric
   * by the trailing integer. Otherwise, ordering is alphabetical.
   * Must return zero if and only if equals(other) returns zero.
   * 
   * @param other the other DirectoryRecord
   * @return sign of comparison (-1, 0, or 1)
   */
  protected int compareAttributes(final DirectoryRecord other) {
    for (final int tag : template.selectionKeys) {
      final String r1a = this.getValue(tag);
      final String r2a = other.getValue(tag);

      // null attributes come before any value.
      if (r1a == null) {
	if (r2a == null)
	  continue;	// equal, move to the next attribute
	else
	  return -1;
      } else if (r2a == null)
	return 1;

      // if they're equal, just move to the next attribute.
      if (r1a.equals(r2a))
	continue;

      int p1 = r1a.lastIndexOf(' ');
      if (p1 == -1) p1 = 0;
      int p2 = r2a.lastIndexOf(' ');
      if (p2 == -1) p2 = 0;

      // If this entry has a space, try an alphabetical
      // comparison of everything up to the last space.
      if (p1 > 0) {
	final int comp = r1a.substring(0,p1).compareTo(r2a.substring(0,p2));
	if (comp != 0)
	  return comp;
      }

      // Try integer comparison (after last space, if any)
      try {
	final int i1 = Integer.parseInt(r1a.substring(p1));
	final int i2 = Integer.parseInt(r2a.substring(p2));
	if (i1 != i2)
	  return i1 - i2;
      } catch (NumberFormatException e) {
	// Nothing clever worked; do simple string comparison.
	assert !r1a.equals(r2a);
	return r1a.compareTo(r2a);
      }
    }
    assert equals(other) : "Nonequal directory records compare zero";
    return 0;	// equal for all the given attributes
  }

  public static class AbstractFactory implements Factory {
    private final Map<Type,Template> types = new HashMap<Type,Template>();

    protected final void addType(final Type type, final Template template) {
      if (null != types.put(type, template)) {
	throw new IllegalArgumentException("redefining template for DirectoryRecord type " + type);
      }
    }

    public DirectoryRecord newInstance(final Type type, final DirectoryRecord upper, final Map<Integer,String> values) {
      if (!types.containsKey(type)) throw new IllegalArgumentException("Undefined DirectoryRecord type " + type);
      return new DirectoryRecord(types.get(type), upper, values);
    }

    public Collection<Integer> getSelectionKeys(final Type type) {
      if (!types.containsKey(type)) throw new IllegalArgumentException("Undefined DirectoryRecord type " + type);
      return new LinkedHashSet<Integer>(types.get(type).selectionKeys);
    }
  }

  public static class BasicFactory extends AbstractFactory {
    public BasicFactory(final Template patientTemplate, final Template studyTemplate,
	final Template seriesTemplate, final Template instanceTemplate) {
      addType(Type.PATIENT, patientTemplate);
      addType(Type.STUDY, studyTemplate);
      addType(Type.SERIES, seriesTemplate);
      addType(Type.INSTANCE, instanceTemplate);
    }
  };

  private static final Factory defaultFactory = new BasicFactory(Template.PATIENT, Template.STUDY, Template.SERIES, Template.INSTANCE);

  public static Factory getDefaultFactory() { return defaultFactory; }

//public final class ConfigurableFactory implements Factory {
//private final Map<Type,Collection<Integer>> types = new HashMap<Type,Collection<Integer>>();

//public ConfigurableFactory(final File configFile) {
//types.put(Type.PATIENT, new TreeSet<Integer>(Type.PATIENT.baseSelectionTags);
//types.put(Type.STUDY, new TreeSet<Integer>(Type.STUDY.baseSelectionTags);
//types.put(Type.SERIES, new TreeSet<Integer>(Type.SERIES.baseSelectionTags);
//types.put(Type.INSTANCE, new TreeSet<Integer>(Type.INSTANCE.baseSelectionTags);

//// TODO: read the config file, add attributes as needed
//}

//public DirectoryRecord newInstance(final Type type, final DirectoryRecord upper, final Map<Integer,String> values) {
//// TODO: implement
//return null;
//}
//public Collection<Integer> getSelectionKeys(final Type type) {
//if (!types.containsKey(type)) {
//throw new IllegalArgumentException("Invalid DirectoryRecord type " + type);
//}
//return new LinkedHashSet<Integer>(types.get(type));
//}
//}
}
